# 最大子数组问题

# 原始问题
```
对于一个数组，求其中和最大的连续非空子数组
eg:
array = [13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, 4, 7]
sub_array = [18, 20, -7, 12]

```

# 解决思路
```
分治法:
1、将原问题拆分为以下三问题：f(min, max) = max{f(min, mid) + f(mid, max) + g(min, mid, max))}
2、新增类型的子问题为：跨过中点的最大子数组；该问题能够较简单的求解:分别从中点向前和向后遍历求和,记录分别的最大值(初始值为0)，得出的值即为g(min, mid, max)，时间复杂度为O(n)
3、将f(min, max)不断进行拆解，最终得到的基础问题的时间复杂度为O(1), 此时递归式为 f(n) = O(1) (if n == 1), f(n) = 2 * f(n/2) + O(n) (if n > 1)
4、此时原始问题的时间复杂度为O(n) + 2 * O(n/2) + 2^2 ^ O(n/(2^2)) ... + n * O(1) = O(nlog(n)) + O(n) = O(nlog(n))
5、空间复杂度为O(log(n))
```

# 其余解决办法
```
1、暴力求解：遍历确定起点，再遍历终点，记录出现过的最大值及此时的min,max，时间复杂度为O(n^2), 空间复杂度为O(1)
2、动态规划：考虑将暴力求解过程中重复计算的内容记录下来，已确定终点角度(将参数从2变成了1)考虑，f(n) = max{f(n - 1) + value(n), value(n)}, 从前往后进行计算，并记录当前最大值对应的min, max, 时间复杂度为O(n), 空间复杂度为O(n)
3、Kadane：将动态规划中保存以i为终止位置的数组删减掉，仅记录上一个结果用于后续使用，将空间复杂度缩减到O(1)
```

*date: 2020-11-16 23:53:23*
